# Android NDK编程

## 1.“Hello Word”

1. 创建JNI目录右键->new->Folder->JNI Folder
2. cd app/build/intermediates/javac/debug/classes
3. 执行命令 javah com.renyushuang.ryscrius.JniHelloWord 生成JNI文件头
4. 将文件com_renyushuang_ryscrius_JniHelloWord.h移动到 jni目录下
5. 创建com_renyushuang_ryscrius_JniHelloWord.c文件

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_renyushuang_ryscrius_JniHelloWord.h"
/* Header for class com_renyushuang_ryscrius_JniHelloWord */

JNIEXPORT jstring JNICALL
Java_com_renyushuang_ryscrius_JniHelloWord_getNewString
        (JNIEnv *env, jobject thiz){

  return (*env)->NewStringUTF(env,"hello word");
}
```

6. CMakeLists.txt创建及语法简单介绍 文件在jni目录下

```cmake
cmake_minimum_required(VERSION 3.4.1)
# 1.指定cmake最小版本
# 命令可选，但是cmake使用了高级的命令，那么需要提醒升级
cmake_minimum_required(VERSION 3.4.1)

# 2.设置项目名称
# 这个命令不是强制的，试了一下，这个命名和你的so库应该相同，如果不同的话找不到so库
#
# 这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，
# 同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR
project(helloJniLib)

## 3.生成动态库
#add_library(helloJniLib SHARED
#            com_renyushuang_ryscrius_JniHelloWord.c)
# 3.1.add_library 默认生成是静态库，通过以上命令生成文件名字，
#
# 在 Linux 下是：
# - helloJniLib 可执行文件
# - helloJniLib.a 静态库
# - helloJniLib.so 动态库
# 在 Windows 下是：
#  - helloJniLib.exe
#  - helloJniLib.lib
#  - helloJniLib.dll

# 3.2.指定包含哪些文件
# add_library(helloJniLib SHARED demo.cpp test.cpp util.cpp)

# 3.3 发现一个目录下所有的源代码文件并把他存在一个列表里
#aux_source_directory(. SRC_LIST)
#add_library(helloJniLib SHARED ${SRC_LIST})

# 3.4 自定义搜索规则
file(GLOB SRC_LIST "*.c" "*.cpp" "protocol/*.cpp")
add_library(helloJniLib SHARED ${SRC_LIST})
## 或者
# file(GLOB SRC_LIST "*.cpp")
# ile(GLOB SRC_PROTOCOL_LIST "protocol/*.cpp")
# add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})
## 或者
# aux_source_directory(. SRC_LIST)
# aux_source_directory(protocol SRC_PROTOCOL_LIST)
# add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})


# 3.5生成可执行文件
# add_executable(demo demo.cpp)

# 3.6生成静态库 Android 使用so只能生成动态链接库
#add_library(helloJniLib STATIC
#        com_renyushuang_ryscrius_JniHelloWord.c)



# Include libraries needed for hello-jni lib
# 设置target需要链接的库
target_link_libraries(helloJniLib # 目标库
                      android # 目标库需要链接的库
                      log) # 目标库需要链接的库

```

7. build.gradle配置

```groovy
defaultConfig {
  
  // CPU架构支持
  ndk {
    abiFilters 'x86_64', 'x86', 'arm64-v8a', 'armeabi-v7a'
  }
}
// 指定CMakeLists路径
externalNativeBuild {
    cmake {
        path "src/main/jni/CMakeLists.txt"
    }
}
```

## 二、AndroidNDK中的代码调用

### 2.1 本地C代码调用Java中的Method

java代码:

```java
public class CallJavaMethodFromNativeCode {
    private static final String TAG = "CallJavaMethodFromNativ";

    static {
        System.loadLibrary("NativeCodeCallJavaMethod");
    }

    public CallJavaMethodFromNativeCode() {
        nativeInit();
    }

    public void setMethodByNativeCode(int value) {
        Log.i(TAG, "setMethodByNativeCode: value = " + value);
    }

    public static void setStaticMethodByNativeCode(int value) {
        Log.i(TAG, "setStaticMethodByNativeCode: value = " + value);
    }

    // C 本地代码初始化方法
    private native void nativeInit();

    // 本地C代码设置非静态方法
    public native void nativeExecution();

    // 本地C代码设置静态方法
    public native void nativeStaticExcution();

}
```

native代码:

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class com_renyushuang_ryscrius_CallJavaMethodFromNativeCode */

/*
 * Class:     com_renyushuang_ryscrius_CallJavaMethodFromNativeCode
 * Method:    nativeInit
 * Signature: ()V
 */

jobject mObject;
jclass mClass;
jmethodID mJMethodID;
jmethodID mJStaticMethodID;

JNIEXPORT void JNICALL Java_com_renyushuang_ryscrius_CallJavaMethodFromNativeCode_nativeInit
        (JNIEnv *env, jobject thiz) {

    jclass clazz = (*env)->GetObjectClass(env, thiz);
    mClass = (*env)->NewGlobalRef(env, clazz);
    mObject = (*env)->NewGlobalRef(env, thiz);
		
  	// 获取java方法id
    mJMethodID = (*env)->GetMethodID(env, clazz, "setMethodByNativeCode", "(I)V");
    mJStaticMethodID = (*env)->GetStaticMethodID(env, clazz, "setStaticMethodByNativeCode", "(I)V");
}

/*
 * Class:     com_renyushuang_ryscrius_CallJavaMethodFromNativeCode
 * Method:    nativeExecution
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_renyushuang_ryscrius_CallJavaMethodFromNativeCode_nativeExecution
        (JNIEnv *env, jobject thiz) {
		// 调用java层非静态方法
    (*env)->CallVoidMethod(env, mObject, mJMethodID, 100);
}

/*
 * Class:     com_renyushuang_ryscrius_CallJavaMethodFromNativeCode
 * Method:    nativeStaticExcution
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_renyushuang_ryscrius_CallJavaMethodFromNativeCode_nativeStaticExcution
        (JNIEnv *env, jobject thiz) {
  	// 调用java层静态方法
    (*env)->CallStaticVoidMethod(env, mClass, mJStaticMethodID, 100);
}
```

### 2.2 本地C代码获得Java对象的属性值

java代码:

```java
public class GetJavaPropertyFromNativeC {


    static {
        System.loadLibrary("NativeCGetJavaProperty");
    }

    private Context context;
    private int numberInJava = 200;

    public GetJavaPropertyFromNativeC() {
        nativeInit();
    }

    private native void nativeInit();

    public native void nativeBusiness();


}
```

native代码:

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"


jobject mObject;
jclass mClass;
jmethodID mJMethodID;
jmethodID mJStaticMethodID;
jfieldID mJFieldId;
/*
 * Class:     com_renyushuang_ryscrius_GetJavaPropertyFromNativeC
 * Method:    nativeInit
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_renyushuang_ryscrius_GetJavaPropertyFromNativeC_nativeInit
        (JNIEnv *env, jobject thiz) {
    jclass clazz = (*env)->GetObjectClass(env, thiz);
    mClass = (*env)->NewGlobalRef(env, clazz);
    mObject = (*env)->NewGlobalRef(env, thiz);
    // 获取java对象中的变量id
    mJFieldId = (*env)->GetFieldID(env, clazz, "numberInJava", "I");
}

/*
 * Class:     com_renyushuang_ryscrius_GetJavaPropertyFromNativeC
 * Method:    nativeBusiness
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_renyushuang_ryscrius_GetJavaPropertyFromNativeC_nativeBusiness
        (JNIEnv *env, jobject thiz) {
    // 获取java对象中的值
    jint numberInJava = (*env)->GetIntField(env, mObject, mJFieldId);
}
```





#### 参考

 [CMakeLists.txt 语法介绍与实例演练](https://blog.csdn.net/afei__/article/details/81201039)

[关于android中的armeabi、armeabi-v7a、arm64-v8a及x86等](https://www.jianshu.com/p/f29ad4beef59)

